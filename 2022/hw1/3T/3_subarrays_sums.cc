/*

==============================Суммы на подмассивах=============================

Имеется массив A из 1 <= N < = 100000 чисел, 10^(-9) <= A_i <= 10^9.

К этому массиву Q раз, 1 <= Q <= 100000 применяют следующее: для каждого
элемента массива от элемента L до элемента R включительно прибавляют число X.

Требуется вывести этот массив после всех таких преобразований.

===============================Input format=====================================

N Q

A_1 A_2 ... A_N

L_1 R_1 X_1

...

L_Q R_Q X_Q

===============================Output format===================================

Ровно N элементов массива через пробел после преобразования.

*/

#include <iostream>
#include <map>
#include <vector>

auto readArray(size_t N) /* I hope RVO works */
{
  std::vector<int32_t> array{};
  array.reserve(N);
  for (size_t i = 0; i < N; ++i)
  {
    int32_t A = 0;
    std::cin >> A;
    array.push_back(A);
  }

  return array;
}

auto readMap(size_t Q) /* I hope RVO works */
{
  std::map<size_t, int32_t> map{};
  for (size_t i = 0; i < Q; ++i)
  {
    size_t L = 0;  /* left border of transformation */
    size_t R = 0;  /* right border of transformation */
    int32_t X = 0; /* added number */

    std::cin >> L >> R >> X;
    map[L] += X;
    map[R + 1] -= X;
  }

  return map;
}

void print(const std::vector<int32_t> &array)
{
  for (auto elem : array)
    std::cout << elem << " ";
  std::cout << std::endl;
}

int main()
{
  size_t N = 0; /* array size */
  std::cin >> N;

  size_t Q = 0; /* number of transformations */
  std::cin >> Q;

  auto array = readArray(N);
  auto map = readMap(Q);

  size_t i = 0;
  int32_t X = 0;
  for (const auto [key, val] : map)
  {
    while (i < key)
      array[i++] += X;

    X += val;
  }

  print(array);
  return 0;
}

/*

Мысли по решению:

1) В лоб

Считываем массив и по очереди выполняем преобразования.
Получается мы Q раз проходимся по части массива.
Сложность: O(N * Q)

2) Объединить преобразования и применить в одном проходе

Наверное надо как-то отсортировать отрезки преобразований.
Например по левому краю. Но что делать с правым концом?
Как определить, что мы больше не преобразовываем?

Мб использовать структуру типа октодерева? Только одномерную.
Вставка отрезка за O(log(Q)).
Заполнение вроде O(Q * log(Q)).
Пересечение числа с отрезками будет занимать O(log(Q)).
Применение преобразований к числу - O(Q).
В итоге имеем O(Q * log(Q) + N * (Q + log(Q)))? Как-то много.

Может как-то собирать преобразования в кучу?
Определенно надо, но как.

3) Пары

Пусть у нас есть преобразование: L_i R_i X_i.
Зададим 2 пары: (L_i, +X_i), (R_i, -X_i).
Все такие пары для всех преобразований можно закинуть в один контейнер
и отсортировать по первому числу. Если первые элементы пар совпадают -- сложить
вторые (Можно просто отсортировать лексикографически). Потом пройтись по всему
этому делу.

Пары кидать можно в std::set. Нужно придумать как пройтись.

Сложность:
Заполнение std::set: O(Q * log(Q))
Пройтись по массиву: O(max(N, Q)) (?)

*/
